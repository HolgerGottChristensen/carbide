use crate::color::{Color, WHITE};
use crate::draw::stroke::StrokeDashPattern;
use crate::draw::{CompositeDrawShape, Dimension, DrawOptions, DrawShape, DrawStyle, ImageContext, ImageId, ImageOptions, Rect};
use crate::math::Matrix4;

use crate::environment::Environment;
use crate::render::layer::{Layer, LayerId};
use crate::text::{TextContext, TextId};
use crate::widget::ImageFilter;

/// # Render context
/// The context is provided using rendering, and provides methods that allows rendering to a scene.
/// The rendering context provides an abstraction over different inner contexts and the environment.
pub struct RenderContext<'a, 'b: 'a> {
    pub render: &'a mut dyn InnerRenderContext,
    pub text: &'a mut dyn TextContext,
    pub image: &'a mut dyn ImageContext,
    pub env: &'a mut Environment<'b>,
}

impl<'a, 'b: 'a> RenderContext<'a, 'b> {
    /// Apply a transform matrix to the renderer that applies to all rendering
    /// instructions of the nested context. This can be used to apply all affine
    /// transformations.
    pub fn transform<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, transform: Matrix4<f32>, f: F) -> R {
        self.render.transform(transform);
        let res = f(self);
        self.render.pop_transform();
        res
    }

    /// Clip the rendering to a given bounding box. When clipping, the nested context
    /// will be clipped. The clipping is applied as an intersection on the existing clipping.
    ///
    /// The clip is always axis aligned, and is not affected by the current transform
    /// of the renderer.
    /// Clipping is the most efficient mechanism for the renderer to discard rendering outside a box.
    pub fn clip<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, bounding_box: Rect, f: F) -> R {
        self.render.clip(bounding_box);
        let res = f(self);
        self.render.pop_clip();
        res
    }

    /// Stencil the nested rendering to a given shape. When making multiple calls to this function
    /// the stencilling is applied as an intersection between the shapes.
    pub fn stencil<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, shape: impl Into<CompositeDrawShape>, f: F) -> R {
        self.render.stencil(shape.into());
        let res = f(self);
        self.render.pop_stencil();
        res
    }

    /// Masking the nested rendering using a given mask. The mask is generated by calling the mask function
    /// with a renderer, rendering to a mask, and applying the mask to the nested renderer.
    ///
    /// When applying a mask, and in an existing mask, only the latest mask is used. They are not
    /// additive.
    pub fn mask<R, F: FnOnce(&mut RenderContext) -> R, R2, F2: FnOnce(&mut RenderContext) -> R2>(&mut self, mask: F2, f: F) -> R {
        self.render.mask_start();
        let _ = mask(self);
        self.render.mask_in();
        let res = f(self);
        self.render.mask_end();
        res
    }

    ///
    pub fn shape(&mut self, shape: impl Into<DrawShape>, options: impl Into<DrawOptions>) {
        self.render.shape(shape.into(), options.into());
    }

    pub fn style<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, style: impl Into<DrawStyle>, f: F) -> R {
        self.render.style(style.into());
        let res = f(self);
        self.render.pop_style();
        res
    }

    pub fn stroke_dash_pattern<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, pattern: Option<StrokeDashPattern>, f: F) -> R {
        self.render.stroke_dash_pattern(pattern);
        let res = f(self);
        self.render.pop_stroke_dash_pattern();
        res
    }

    pub fn image(&mut self, id: ImageId, bounding_box: Rect, options: impl Into<ImageOptions>) {
        self.render.image(id, bounding_box, options.into());
    }

    pub fn text(&mut self, text: TextId) {
        self.render.text(text, self.text);
    }

    pub fn layer<R, F: FnOnce(Layer, &mut Environment) -> R>(&mut self, layer_id: LayerId, bounding_box: Rect, f: F) -> R {
        let layer = self.render.layer(layer_id, bounding_box.dimension, self.env);
        let res = f(layer, self.env);
        self.render.render_layer(layer_id, bounding_box);

        res
    }
}

impl<'a, 'b: 'a> RenderContext<'a, 'b> {
    pub fn filter<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, filter: &ImageFilter, bounding_box: Rect, f: F) -> R {
        let res = f(self);
        self.render.filter(filter, bounding_box);
        res
    }

    pub fn filter2d<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, filter1: &ImageFilter, bounding_box1: Rect, filter2: &ImageFilter, bounding_box2: Rect, f: F) -> R {
        let res = f(self);
        self.render.filter2d(filter1, bounding_box1, filter2, bounding_box2);
        res
    }

    pub fn filter_new<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, filter: &ImageFilter, f: F) -> R {
        self.render.filter_new();
        let res = f(self);
        self.render.filter_new_pop(filter, WHITE, false);
        res
    }

    pub fn filter_new2d<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, filter: &ImageFilter, filter2: &ImageFilter, f: F) -> R {
        self.render.filter_new();
        let res = f(self);
        self.render.filter_new_pop2d(filter, filter2, WHITE, false);
        res
    }

    pub fn shadow<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, id: &ImageFilter, id2: &ImageFilter, color: Color, f: F) -> R {
        self.render.filter_new();
        let res = f(self);
        self.render.filter_new_pop2d(id, id2, color, true);
        res
    }
}

impl<'a, 'b: 'a> RenderContext<'a, 'b> {
    /// Hue rotation given in turns.
    pub fn hue_rotation<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, rotation: f32, f: F) -> R {
        self.render.color_filter(rotation, 0.0, 0.0, false);
        let res = f(self);
        self.render.pop_color_filter();
        res
    }

    pub fn saturation_shift<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, shift: f32, f: F) -> R {
        self.render.color_filter(0.0, shift, 0.0, false);
        let res = f(self);
        self.render.pop_color_filter();
        res
    }

    pub fn luminance_shift<R, F: FnOnce(&mut RenderContext) -> R>(&mut self, shift: f32, f: F) -> R {
        self.render.color_filter(0.0, 0.0, shift, false);
        let res = f(self);
        self.render.pop_color_filter();
        res
    }
}

pub trait InnerRenderContext {
    fn transform(&mut self, transform: Matrix4<f32>);
    fn pop_transform(&mut self);

    fn color_filter(&mut self, hue_rotation: f32, saturation_shift: f32, luminance_shift: f32, color_invert: bool);
    fn pop_color_filter(&mut self);

    fn clip(&mut self, bounding_box: Rect);
    fn pop_clip(&mut self);

    fn filter(&mut self, filter: &ImageFilter, bounding_box: Rect);
    fn filter2d(&mut self, filter1: &ImageFilter, bounding_box1: Rect, filter2: &ImageFilter, bounding_box2: Rect);

    fn stencil(&mut self, shape: CompositeDrawShape);
    fn pop_stencil(&mut self);

    fn shape(&mut self, shape: DrawShape, option: DrawOptions);

    // TODO: Consider making it take a reference to Style
    fn style(&mut self, style: DrawStyle);
    fn pop_style(&mut self);

    fn stroke_dash_pattern(&mut self, pattern: Option<StrokeDashPattern>);
    fn pop_stroke_dash_pattern(&mut self);

    fn image(&mut self, id: ImageId, bounding_box: Rect, options: ImageOptions);

    fn text(&mut self, text: TextId, ctx: &mut dyn TextContext);

    fn filter_new(&mut self);
    fn filter_new_pop(&mut self, filter: &ImageFilter, color: Color, post_draw: bool);
    fn filter_new_pop2d(&mut self, filter: &ImageFilter, filter2: &ImageFilter, color: Color, post_draw: bool);

    fn mask_start(&mut self);
    fn mask_in(&mut self);
    fn mask_end(&mut self);

    fn layer(&mut self, layer_id: LayerId, dimensions: Dimension, env: &mut Environment) -> Layer;
    fn render_layer(&mut self, layer_id: LayerId, bounding_box: Rect);
}